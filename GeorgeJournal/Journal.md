The Beginning:
For the first week of journaling my process in this assignment, I will begin with our project proposal submission. We wanted to create a web application, or at least a prototype of a web application, that would use a lot of the functionality we have been going through in our lectures, with some added things that we think would spice up the project a bit. One major thing we had to keep in mind was to scale this assignment appropriately since we ended up with only two members on the team. Thankfully, we were able to get a good project proposed with a good idea of how we wanted the data models to exist, and what kind of functionality would be involved.

After the initial proposal was submitted, we began setting up the actual repository. We decided to pair program as a team via Zoom so that we both have a good idea of how the project is set up. We went through the process of using an express generator to create a basic express application with all of the initial file structure set up. We referenced the class Doggr repository for some assistance on getting the back end created with data models. I, personally, found that it was super helpful to have Doggr as a reference since we have gone over the creation of these files in class, so the concepts for creating an express project were further solidified through our own development. We also had another pair programming session where we created the front end in react, also referencing Doggr to fill in some blanks that we couldn't initially figure out. Both of these sessions made it possible for us to start branching out and doing our own separate tasks independently. In this process, Kaleb set up a Trello board for us to use and at the end of our second pair programming meeting, we began assigning our tasks for functionality we would build.

For this project, we decided to focus our individual tasks on specific functions of the program, rather than separating by front end & back end. We decided on this because we both wanted to learn about the full stack of the program as we were putting it together, rather than only focusing on one end.

Users:
We began working on our independent tasks this week. I focused on creating an 'Add User' form on the front end and Kaleb created all of the backend functionality. Although we planned to have each task focus on the full stack, we decided to separate this task into front and backend due to how much initial work it takes to create the first actual piece of creation and retrieval functionality into a bare application. Kaleb handled a lot of the docker container initialization that helped make it so we could persist data. He also added in back end routes so that the front end can create new users. Before Kaleb submitted the new backend updates, I went ahead and began adding in some functionality for models, services, and components to the front end so it would be ready for the user creation update. After Kaleb merged his updates into our repository, did some testing in Postman to figure out how exactly I should have the model set up in the front end, and also have a good idea of what route I should be targeting for the front end services. Then, I created a simple user creation form in the front end and completed that part of our user functionality. This was one of the first forms created for the application, so I tried my best to follow along with the kind of organization we used in our Doggr projects to set the precedent for other functions.

The next task with user creation was to also implement user authentication. I decided to take on user authentication because I wanted to get a better understanding of it after we went over it in class. With the help of reviewing our lectures and the functionality we went over in Doggr, I felt a good understanding on how to implement authentication on the front end & back end. I was able to add authentication and hashing user passwords in our creation functionality, which began the process of working in both the front end and backend.

In the process of implementing authentication, I ran into some issues that I was later able to resolve although I felt silly after I realized the issue. The problem was that I did not have an environment variable stored for token secret, so I couldn't generate an access token in the backend. It took me a while to realize I had not updated our .env file with a token secret, so after that was updated, I was able to get authentication working.

After creating users, I began working on adding a test suite, which was another task I had taken on for the initial set up of our program. I revisited our lecture materials in order to remember how Jest setup works in an express program, so I installed the necessary packages and included a configuration file so we could add a test file to test some of our user endpoints. This was a tricky task since I was not too familiar with getting an actual test to run in Jest, since I have only truly worked with it when there are already tests set up. In this process, I used the "let result = 2+3" test in order to make sure I had Jest running properly. I have found that simple tests like these have helped me greatly with adding other functionality in this program, since it is easy to overlook a lot of the initial configuration and just move on to implementing bigger things right away. After this worked, I began trying to test the services and other backend functionality and realized I was doing it all wrong - I'm supposed to be testing the endpoints instead. With this realization, I changed the Jest tests to call on the app's endpoints and check for correct status responses. In the case of the authentication endpoint, I checked to make sure that the response has a '200' OK response code and a message large enough to be a token. 

Plants:
Our next individual task assignments were to create Plants and a new Microservice. Since we are on a graduate level team, we are required to include at least one microservice in our project. We decided to have two microservices so that, along with our exposure to the full stack of our application, we will also get a good understanding of C# as well. We had another checkin where we assigned these tasks and began implementing.

Through the process of creating this functionality, I misunderstood our plans to create a Plant Microservice vs. creating plant profiles on the front end. What happened is that I ended up creating both plant profiles AND plants on the backend application. We had another checkin for our project, during which Kaleb suggested that we repurpose the Plant Microservice to be used for forums, and I would create a microservice for Journals & entries and we agreed to keep backend plant creation.  

After Kaleb's microservice was merged into our repository, I attempted to run the microservice on my own computer just to make sure the setup would work properly. I ran into some issues where the shell script to build the microservice would not run at all, due to some formatting issue. It turns out that the shell script file had carriage return characters added all throughout where new lines were created, and carriage returns are not recognized in shell scripts. It appears that this was happening due to my computer being on Windows, and git somehow adding the character due to my operating system. I did some research in order to figure out how to fix this file, which ended up being a setting I could use in Notepad++ to change EOL conversion to Unix. After finding this solution, I struggled a bit with getting the file updates to work in the terminal before realizing I was using the cached shell script before I updated the file, so I included '--build' in our docker compose call and everything was building correctly!

The process of including plant creation in the backend application was made a bit smoother by already having User creation in our application. I've noticed through the process of creating Botanical Buddies that it often becomes easier to add new functionality once other functions are already built in place, since you can build on top of an already existing structure. When I initially created the models for plants in this program, I originally wanted to create a Plant database and a UserPlant database to map the users and plants. I found that this felt unnecessary after I had already added these models to the database, so I decided to instead just stick with including a UserID in plants so that they can be linked to a user. I then created routes in the backend in order to 

Part of the process of creating a new plant involved adding new functionality to actually display the plant. With this, I created a new 'UserProfile' component so that a user can see all of their plants. The process of actually retrieving data and displaying it in React was a new challenge that I undertook. I had initially tried to start implementing data retrieval on our second assignment, when we added a creation form in Doggr. I wanted to retrieve a list of pet profiles, but ran into issues with asynchronous GET calls. Initially, I decided to pull all plants through an initial state on page load like we did for Doggr, and then worry about on-demand retrieval later. 

Minio:
After we had some good plant functionality working, it was time to start creating the ability to upload images for plants, so we can have a visually pleasing front end. I did not end up using minio in our second programming assignment, so this was going to be all new to me. Thankfully, we went over minio implementation in our lectures and I had Doggr to reference for how it should be correctly implemented. I was able to get the Minio service created and add in some file uploading and storing functionality based on what we went over in class. The whole process really helped reinforce the information from our lectures and purpose behind some of the configuration settings. I did repeat my same error of not including environment settings in the .env file, but that ended up being the last time I overlooked that. A lot of this process started out with testing file upload via Postman, which included some hiccups involving filenames and configuration. Once it was working, I felt confident enough to move into actually creating a front end.

The file upload front end required a whole new level of work, which was when I began experimenting more with the basic creation forms I was normally used to in React. This required including an 'on file change' type of function in the Plant creation form component, which would tell the plant service what file to include in the post request's form data. Speaking of which, form data was also new since I was used to passing in an object as JSON through the request body. However, the form data option is best optimized for including a file, so I included that as a requirement for the plants POST endpoint. After quite a bit of troubleshooting little details I had missed out on, I had file upload working on the front end.

Now, after implementing file upload, I decided to begin creating endpoints to load plants based on userID, or an individual plant by its ID, just so that we would be ready to use those when we want to create new component routes in the front end. This was something I continually worked on as I was working on other things like a user profile page. 

Journals:
The next step was to take a dip into the world of .NET Microservices. Thankfully, Kaleb had done a lot of work in setting up the first microservice for Plants (then Forums), so he was able to help me set up my first microservice that I would use to manage Journals. 

The first step was to create the microservice itself. After I got the initial set up working for my new microservice, I moved into the work of including a DB context and model .For whatever reason I started out with wanting to create Journal Entries instead of the actual Journals themselves, so I implemented a journal entry model with my .NET microservice. After working around a bit with generating the migrations, I was able to get a microservice running with endpoints for getting & creating new journal entries. The next step was to incorporate a Journal model into the microservice so that I could have a journal element with entries as the child. This was easy to add but I ran into issues with generating a new migration without conflicting with the already existing entry model. It turns out I had set the DB context wrong and I also needed to create a new configuration file for my new model, so after fixing that issue I was able to get both models existing side-by-side.

I also created a front end, which started out with a lot of issues with CORS and not having the authorization to even access the microservice. I found out that a solution to this problem was to include "UseCors()" in the .NET microservice with the front end's localhost URL so the front end would be allowed access. After that, it was still a very time-consuming process of figuring out how to use ID parameters in component routes, and how to call on asyncronous REST requests to pull in elements onto a page. This process ended up being what helped make React front end components feel less of a mystery to me. For a while, I was struggling to get props and the 'useEffect' function working and typically managed to get something barely working for most of my front end pages. Props were still kind of iffy in my head since I had only implemented them a couple of times already, but once I started to really dig more into it I finally had an understanding of how they can be passed down and how variables can be set through states in each component. After getting one of my control panels to correctly load journal entries based on a journalID, I could now use that to implement the same functionality into the Plants component and other places.

I mentioned previously that it gets easier to add new functionality after other things have already been put in place, and this was a great example of how exponentially I was able to start adding in new things to the project. Suddenly, it only takes about 20 minutes to add a new component with REST requests to the front end whereas I was spending hours trying to get something to work initially. However, I still spent quite a bit of time messing with props in the front end components due to occasionally getting variable names wrong, or not including an initial state which would make some of the variables be nullable, which would break compilation.

Draft Submission
Now we are at the point where we are ready to submit a rough draft of our program for review, before the final submission date on June 8th. We had another checkin on the project and we both felt very confident on what we have set up already. With this checkin, we merged in our updates and I was able to use Kaleb's new extensions to authorization in order to use a 'logged in' state and retrieve the current user's ID to display/hide certain elements. Thankfully there were no conflicts that had any effect on the pages I created for journals, so I was able to implement functionality that displays a 'create new entry' form on a user's journal if they are logged in. However, this form will not show on a different user's journal or if you are logged out. I also fixed the UserProfile component so that it can pull in the current user's ID, so there is no requirement for there to be an ID in the URL parameters. However, I still included the URL parameter as well in case we wanted to showcase a user's profile much like you would see on any social media site. There are still a few things to do like adding in styles and removing some generated Minio files from our repository, but we are on track to have an excellent final project for this term.

