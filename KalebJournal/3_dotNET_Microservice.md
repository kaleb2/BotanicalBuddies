Implementing a Minimal API
    I am familiar with Microsoft documentation and learning about Microsoft technologies because it is what I use at work. I knew that I wanted to make a .NET core web server and found there is a template project for creating a microservice called Minimal API. Following the tutorial, I created a new template project via the dotnet command line tool. One of the coolest things about this Minimal API template is the program file works almost exactly like our server.ts file does. Ignoring the WebApplicationBuilder for dependency injection, the app itself is pretty much an express object. I was able to add my routes with nearly identical code the routes in server.ts. This plus my knowledge of C# made the implementation easy. The harder part was figuring out the O/RM to use in place of sequalize.

Adding EntityFrameworkCore
    Upon further research I found that EntityFrameworkCore (EF Core) was the Microsoft preferred library for databases. Following another tutorial, I was able to add the EF Core packages to the service. Next, I needed to create the model for plants to be used in the database. I created a plant class and adorned it with the necessary attributes. I added Required for when a property is required. I also added ColumnName to name them with proper camelCase rather than the capitalized PropertyCamelCase. That way if the table is used by the express service, the table naming scheme is consistent. Lastly, I added the Table attribute to the class to name the table. Next, I needed a DbContext class that described how to connect to the database and set up my model. This is where things got more challenging.

    After creating my DbContext based on the tutorial I faced two main problems, one was the connection string format, and the other was the table creations. For the connection string it took me several tries to finally get it all correct. My first problem was figuring out which method to use for injecting my DbContext into the service.

    My first attempt was .UseSqlServer(connectionString) which complained about the format of the connection string. I found a resource to explain the format for the connection string. However, once I got the format correct, I got another error that the database was dropping the connection. I was quite confused for a bit. I searched around for another tutorial and found one that has .UseNpqsql(connectionString) as the dependency injection. This was the ticket after I reformatted the connection string again.

    The final piece of this puzzle was the table creation. I needed to understand how to seed this database from EF Core. I found that this requires installing a EF tool for dotnet. Easy enough, I installed the tool from the command line, created a Migration, and then executed that migration to populate the database. To make this even cleaner, the PlantEntityTypeConfiguration is used to encapsulate the seed data, so it doesn't have to get confused with the DbContext class, or the Plant model. 
    With all of that figured out I had a .NET microservice that could connect to the database and write new records. I knew this couldn't be the end though. I needed to containerize this app so George could run it on his computer without having to install dotnet or any other Microsoft techs.

Containerizing ASP.NET App:

    This was by far the trickiest part of the microservice. I got stuck on several things, but the biggest and longest hang-ups were creating a docker file for PlantService, getting EF Core to work in the container, connecting the PlantService to the database within the docker network, and connecting to the PlantService from outside the container. 

    First, creating the docker file. I found a tutorial for creating a ASP.NET app that connects to a postgres database, exactly what I wanted to do. This tutorial had me make a docker file that would copy the project in, use dotnet to restore and build the project, then use a bash script as the entry point. The bash script would migrate the database and then start the server. The primary issue with this tutorial is the script fails when using the EF Core tool to migrate the database. I tried that to install the EF Core tool manually which kind of worked but would fail on the second run because it already existed. I also tried running the migration in the docker file, but that would fail because botpostgres wouldn't be started yet in the build phase. 

    The solution was a little bit of both. I installed the EF Core tool in the docker file so it would only happen when the container was built. This would allow the migration to occur in the entry point script after botpostgres was up and running. The perfect solution! But still not the end of my problems.

    The next issue wasn't too bad, once I got the migration running, I found it would fail because it couldn't find the postgres server address. I tracked down that because this service was running in a docker network now, it couldn't find the postgres service on localhost anymore. Instead, I just needed to update the connection string to use the name of the service on the docker network. Boom, PlantService is up! But only in theory. My final issue, which was a painful one, I couldn't hit the server from the outside. 

    The container logged that the server was running on localhost:9100, but I couldn't get anything out of it. I couldn't send a curl request, I couldn't use postman, nothing. So, I went into the docker file, and I tried changing which ports were exposed, I tried running the server with a different command, I tried adjusting the docker-compose file to add a network manually. Nothing worked and I was going crazy because it said it was working but it wasn't. So, what the heck?! Finally, I found a resource saying the problem was binding to localhost. I had nothing else to try so I changed the code to run on "0.0.0.0:9100" instead of localhost. At long last, it worked. I had a fully containerized .NET microservice that could receive requests and save plants to the database. I then realized that George was building that exact thing in the express service. It was going to be fine though, I could adapt it to do something else, that's the easy part. Great success!

Running the App on not my computer
    The real test for my service was, could George run it on his computer. He faced one tiny issue that I was able fix. It was a silly little line ending issue. Because the entry point script runs in the container it was essential that it has the Unix line endings. I had fixed this myself, but git clients can easily mess that up. After I told George about the issue, he fixed the line endings, rebuilt the container, and it worked! He didn't have to install any dotnet tools, it just worked, and I was quite pleased. Great success!

Checking in:
    I was so happy that George could run the microservice, the only problem was I created the same thing he had created in express. So, our next plan was, I would adapt the microservice I made to be the forum service. George would make a new microservice that can be the journaling service. Now we could finally develop full stack features.
